services:
  # --- PostgreSQL Database Service ---
  db:
    # Use an official Postgres image. It will auto-detect your RPi's ARM architecture.
    image: timescale/timescaledb:latest-pg15
    container_name: discord-bot-db
    restart: always # Always restart the container if it stops
    
    ports:
      - "5432:5432" # Host_Port:Container_Port

    # Environment variables to configure the database
    environment:
      POSTGRES_DB: ${POSTGRES_DB}    # The name of your database
      POSTGRES_USER: ${POSTGRES_USER}     # The username for your database
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}

    # Attempted fix for latency connecting PC to DB.
    command: postgres -c listen_addresses='*' -c log_hostname=off -c shared_preload_libraries=timescaledb
    # This section mounts a persistent volume
    # If the container is deleted, your data in 'pg_data' survives.
    # volumes:
    #   - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    #   - pg_data:/home/prismatic/Discord/bot/database/pg_data:/var/lib/postgresql/data
    volumes:
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
      - pg_data:/var/lib/postgresql/data

    healthcheck:
      # This command checks if Postgres is ready to accept connections
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s     # Check every 10 seconds
      timeout: 5s       # Give up after 5 seconds
      retries: 5        # Try 5 times before failing
      start_period: 10s # Wait 10 seconds before the first check

    # Add this service to our custom network
    networks:
      - echo-network

  # --- Your Discord Bot Service ---
  bot:
    # 'build: .' tells compose to look for a 'Dockerfile' in the current directory
    # If your bot's Dockerfile is elsewhere, adjust the path (e.g., './bot-code')
    build: .
    container_name: echo4-prod-container
    restart: always

    # This ensures the database container is started *before* your bot starts
    depends_on:
      db:
        condition: service_healthy

    # Pass database connection details to your bot as environment variables
    # Your bot code will read these to connect.
    environment:
      DATABASE_HOST: db   # This is the 'service name' of your database (from above)
      DATABASE_PORT: 5432
      DATABASE_NAME: ${POSTGRES_DB}       # Must match POSTGRES_DB
      DATABASE_USER: ${POSTGRES_USER}     # Must match POSTGRES_USER
      DATABASE_PWD: ${POSTGRES_PASSWORD}
      # Discord Details  
      DISCORD_TOKEN: ${DISCORD_TOKEN}
      OWNER_ID: ${OWNER_ID}
      ADMIN_SERVER_ID: ${ADMIN_SERVER_ID}
      GQ_SERVER_ID: ${GQ_SERVER_ID}

    # Add this service to our custom network
    networks:
      - echo-network

    logging:
      driver: "json-file"   # Keeping Json default.
      options:
        max-size: "15m"     # Max size of a single log file (e.g., 10 MB)
        max-file: "5"       # Files to keep.

  # --- Grafana Dashboard Service ---
  grafana:
    image: grafana/grafana-oss:latest
    container_name: bot-dashboard
    restart: always
    ports:
      - "3000:3000" # Access Grafana UI at http://<your-host-ip>:3000
    
    volumes:
      - grafana_data:/var/lib/grafana # Persist dashboards and settings
      
    depends_on:
      db:
        condition: service_healthy # Wait for the DB to be ready
        
    networks:
      - echo-network
# --- Top-Level Definitions ---

# Defines the persistent volume we named above
volumes:
  pg_data: # Echo 4 Data
    driver: local
  grafana_data: # Grafana
    driver: local

# Defines the custom network
# Services on the same network can find each other by their service name (e.g., 'db')
networks:
  echo-network:
    driver: bridge